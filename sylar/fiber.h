#ifndef __SYLAR_FIBER_H__
#define __SYLAR_FIBER_H__

#include<memory>
#include "thread.h"
#include<functional>
#include<ucontext.h>

namespace sylar {
class Scheduler;
class Fiber : public std::enable_shared_from_this<Fiber> { //继承了该类，则无法在栈上建立对象,类内成员可通过
friend class Scheduler;                                    //shared_from_this()方法获取当前对象的智能指针	
public:																								 
		typedef std::shared_ptr<Fiber> ptr;
		enum State {
			INIT,
			HOLD,
			EXEC,
			TERM,
			READY,
			EXCEPT
		};
private:
	Fiber();
public:
	Fiber(std::function<void()> cb, size_t stacksize = 0, bool user_caller = false);
	~Fiber();
	
	//重置协程函数，并重置状态
	//INIT,TERM
	void reset(std::function<void()> cb);
	//切换到当前协程执行
	void swapIn();
	//切换到后台执行
	void swapOut();
	void call();
	void back();
	uint64_t getId() const {return m_id;}
	State getState() const { return m_state;}
public:
	//返回当前协程
	static Fiber::ptr GetThis();
	//设置当前协程
	static void SetThis(Fiber* f);		
	//协程切换到后台，并且设置为Ready状态
	static void YieldToReady();
	//协程切换到后台，并且设置为Hold状态
	static void YieldToHold();
	//总协程数
	static uint64_t TotalFibers();
	
	static void MainFunc();
	static void CallerMainFunc();
	static uint64_t GetFiberId();
private:
	uint64_t m_id = 0;
	uint32_t m_stacksize = 0; //栈大小
	State m_state = INIT;
	
	ucontext_t m_ctx; //上下文
	void* m_stack = nullptr; //栈空间
	
	std::function<void()> m_cb;
};

}
#endif